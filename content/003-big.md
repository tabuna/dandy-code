# Великий монолит

После прочтения `README` в любом проекте возникает естественное желание оценить масштаб работы. 
Насколько велика система? Насколько быстро я смогу в ней разобраться и начать вносить изменения?

Во многих экосистемах по умолчанию доминирует монолитный подход. 
Это классика, проверенная временем. 
Его используют:

- Laravel (PHP)
- Django (Python)
- Ruby on Rails (Ruby)
- Phoenix Framework (Elixir)
- Spring (Java)
- Sails (Node.js)

И этот список можно продолжать долго — монолиты надёжны, удобны и, что важно, имеют широкую поддержку в виде инструментов и сообществ. 
Это безопасная отправная точка практически для любого проекта.

Однако столкнуться с **20 000+** файлов и папок в репозитории — для любого разработчика может стать демотивирующим
шоком.
Это словно стоять перед огромным валуном и пытается его сдвинуть с места.

Даже опытный разработчик теряет мотивацию, когда не видит четкой структуры, границ ответственности, понятных точек входа.
Это не просто психологический барьер — это профессиональная фрустрация: ты не понимаешь, где начать, как не сломать, как внести изменения безопасно.

В любой работе, будь то программный код, список дел или физическая работа — есть
одно универсальное правило: разбивай большую задачу на маленькие части.

Это вовсе не значит, что каждый монолит обязательно нужно дробить на десятки микросервисов. Нет, не стоит
драматизировать. 
Речь о том, что даже внутри монолита обязательно нужно выделять и изолировать компоненты, которые можно вынести в
отдельные репозитории.

Например, в приложении для прогноза погоды класс температуры который может автоматически записываться как в Цельсиях,
так и в Фаренгейтах, то его можно выделить отдельно от монолита:

```php
class Temperature
{
   // ...
}
```

Этот компонент можно вынести в собственный репозиторий, покрыть тестами, 
добавить документацию и подключать через Composer как внешнюю зависимость.

Такой подход упрощает основную кодовую базу и снижает когнитивную нагрузку: вместо тысячи связанных между собой файлов 
разработчик имеет дело с чётко очерченным, изолированным модулем. 

Кроме того, переиспользуемые и опубликованные компоненты не просто сокращают дублирование — они создают эффект "внешней
границы", когда ответственность модуля очевидна и проверяется временем.

Разработчику становится проще работать с проектом. Показав небольшой модуль, он скажет и подумает:
«Да, я могу разобраться с этим и внести изменения», — а потом постепенно расширять понимание всего проекта и его частей.
Это сильно снижает тревожность и прокрастинацию. Чем понятнее и локальнее задача — тем выше вовлечённость.


Кроме того, отдельные небольшие пакеты часто можно и нужно выкладывать в open source — это не то, что подпадает под
ограничения или коммерческую тайну. Это чистый, полезный, часто общепринятый код.

Они могут стать отличным инструментом для профессионального роста и демонстрации своих навыков.

Часто можно встретить талантливых разработчиков, которые годами работают внутри одной компании, в огромном монолите,
но не могут продемонстрировать ни одной строчки открытого кода. 
Почему? Потому что весь их труд спрятан за корпоративным VPN, внутри безликой и плохо структурированной массы.

Поэтому небольшие компоненты и пакеты — это одновременно и технический, и карьерный инструмент, который стоит
использовать каждому разработчику.
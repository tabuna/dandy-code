# Загадочные значения

Никто не начинает изучение проекта с вдумчивого чтения всей вики. 
Разработчик открывает IDE, запускает поиск по имени метода или класса, и — вперёд, прямо в код. 
Только когда поведение становится неочевидным, когда логика не складывается — он обращается к документации, вики, базе знаний если такая вообще есть или еще хуже к колеге выпрашивая информацию по чайной ложке.

Рассмотрим распространённую ситуацию:

```php
// Плохо ❌
if ($status == 1) {
    // ...
}
```

На первый взгляд — ничего страшного. Просто проверка статуса.
Но что значит это число `1`? Почему именно оно?

Разработчик, который это писал, наверняка знает, что `1` здесь означает "активный статус".
Но для всех остальных — это магическое число, появившееся из ниоткуда.
Код превращается в загадку: *почему не `0`? А может быть ли значение `2`? А в статус приходит `1` или `true`?*

Теперь представьте, что этот код читает кто-то вроде меня — из мира Linux.
В Unix-системах код `0` означает успешное завершение, а `1` — **ошибку**.
И я интуитивно читаю этот код иначе: *"О, тут проверяется, что была ошибка?"*
Мои привычки вступают в конфликт с чужими соглашениями — и я начинаю сомневаться в логике самого кода.

А если значение гораздо больше, например:

```php
// Плохо ❌
if ($status == 24) {
    // ...
}
```

Что это значит? День рождения начальника? Номер ошибки? Идентификатор тайного соглашения?

Загадочными могут быть не только числа. Иногда код притаит за собой с набор символов:

```php
// Плохо ❌
if ($char === '%!') {
    // ...
}
```

Что значит `%!`? Если значение несёт смысл, пусть оно громко заявляет о себе именем. Тогда станет ясно, зачем он здесь и как его использовать дальше с помощью константы:

```php
// Хорошо ✅
const STATUS_ACTIVE = 1;

if ($status === STATUS_ACTIVE) {
    // ...
}
```

Теперь код стал более понятным и поддерживаемым. 
При его чтении сразу становится понятно, что проверяется в условии.

Можно пойти дальше ещё дальше и использовать перечисления для явного определения различных значений:

```php
enum Status: string
    case ACTIVE = 'active';
    case INACTIVE = 'inactive';
    case ARCHIVED = 'archived';
}

$status = Status::ACTIVE;

if ($status === Status::ACTIVE) {
    // ...
}
```

```php
enum Status: int
    case ACTIVE = 1;
    case INACTIVE = 2;
    case ARCHIVED = 3;
}

$status = Status::ACTIVE;

if ($status === Status::ACTIVE) {
    // ...
}
```

Такой подход делает код более читаемым и позволяет явно указать доступные значения статуса и использовать как типизированное значение в методах, например:

```php
function canBePublished(Status $status): bool
{
    // ...
}
```

Используя именованные константы или перечисления, мы делаем код более понятным и поддерживаемым, ведь нам не нужно обращаться ни к документации, ни к коллеге, за прояснениями что важно для разработки масштабируемых приложений.


### Переизбыток констант

Когда речь заходит о «магических значениях», первый инстинкт многих начитанных разработчиков — немедленно заменить каждое из них на именованную константу. 
Как было показано ранее, это логично, но не всегда разумно. Проблема не в самих константах, а в том, как читается код и насколько понятна его суть.

Рассмотрим реальный пример:

```php
class Order
{
    // ...

    public function daysSinceLastUpdate(): float
    {
        return (((($this->$lastUpdatedAt / 1_000_000) / 60) / 60) / 24);
    }
}
```

Здесь мы видим цепочку арифметических операций, и каждый разработчик, читающий этот код, вынужден мысленно раскручивать её:
 «Так, это микросекунды, потом секунды, потом минуты... ага, значит это перевод времени в дни». 
Это усложняет чтение и отвлекает от сути метода.


После слепого ввода констнат пример начиает выгрядеть так:
```php
// Плохо ❌
class Order
{
    private const MICROSECONDS_IN_SECOND = 1_000_000;
    private const SECONDS_IN_MINUTE = 60;
    private const MINUTES_IN_HOUR = 60;
    private const HOURS_IN_DAY = 24;

    public function daysSinceLastUpdate(): float
    {
        return $this->lastUpdatedAt
            / self::MICROSECONDS_IN_SECOND
            / self::SECONDS_IN_MINUTE
            / self::MINUTES_IN_HOUR
            / self::HOURS_IN_DAY;
    }
}
```

Формально — код стал «говорящим». Но читается он по-прежнему тяжело. Мы заменили магию чисел на магическое количество деталей,

Вместо того чтобы «расшифровывать» механику времени вручную, лучше полностью передать заботу об этом классу, который создан именно для этой работы. 
Например, `Carbon`:

```php
// Хорошо ✅
use Carbon\Carbon;

class Order
{
    public function daysSinceLastUpdate(): float
    {
        return Carbon::createFromTimestampMicro($this->lastUpdatedAt)
            ->floatDiffInDays(now());
    }
}
```

Не всякое «магическое значение» нужно заменять на константу. Иногда лучший способ устранить магию — не объяснять детали вообще. Спрячьте реализацию за выразительным интерфейсом. Пусть код говорит что он делает, а не как.

Еще лучше, будет если наши свойства будут не приметивные данне, а сразу обьеты, тогда:

```php
// Хорошо ✅
use Carbon\Carbon;

class Order
{
    public function daysSinceLastUpdate(): float
    {
        return $this->lastUpdatedAt->floatDiffInDays(now());
    }
}
```

# Именование

Иногда достаточно открыть структуру проекта, чтобы многое понять о команде. И не в лучшую сторону.
Например, можно встретить такие каталоги:

```php
project
├─ old_config
├─ mordor
├─ black_magic
└─ ...
```

Причин для их появления масса. Кто-то просто скопировал старую директорию. Кто-то решил временно “вынести в сторону”
непонятный или страшный код. Но так и не разобрался, что с ним делать. А потом это «временно» прижилось и стало частью
архитектуры. Это симптом того, что именованию в проекте никто не уделяет
внимания. А ведь имена — это первая линия коммуникации.

Теперь представьте, что вы открыли чужой код и наткнулись на переменные:

```php
$pogoda;
$veter;
$solnce;
```

Такие имена мгновенно выдают новичка.

Это напоминает, как я писал СМС-сообщения в нулевых: тогда сообщения имели ограничение по
количеству символов, а на латинской раскладке в одно сообщение помещалось намного больше текста, чем при использовании кирилицы.
По этому если не удавалась уложиться в лимит, я писал транслитом:

```text
Privet. Mi segodnya vtretimsa v parke?
Ya vzal s soboy...
```

Это была вынужденная мера, но та эпоха давно закончилась.
В программном коде большинство фреймворков, библиотек, документаций — на английском.
Когда в коде:

```php
class Order extends Controller
{
    public function ...()
    {
        // ...
        foreach ($zakazy as $tovar) {
            $product->otpravka($tovar);
        }
        // ...
    }
}
```

Создается разрыв контекста, фреймворк говорит на одном языке, твой код — на другом.
Переключаться между языками утомительно, особенно в больших проектах.
Это снижает читаемость и замедляет понимание.

Если имена переменных, файлов, классов, папок не передают смысл, они становятся ментальным мусором.
Чем их больше — тем труднее читать, понимать и поддерживать код.

Поэтому нужно заботиться об именовании. Но что делает имена хорошими?
И как начать исправлять это прямо сейчас?

Некоторым разработчикам нравятся использовать сокращения в именах, что кажется для них удобным и помогает ускорить написание кода.
Некоторые языки даже рекомендуют подобный подход — например, в Go советуют:

> The name of a method's receiver should
> be a reflection of its identity; often a one
> or two letter abbreviation of its type
> suffices (such as c for cl or s for
> Server). Don't use generic names such
> as me, this, or self.

Сокращения могут быть как однобуквенными, так и более длинными или смешанными, например итерация цикла как `$i`, запрос как `q`, интерфейс как `IComponent`.
Однако зачастую такие сокращения лишь приводят к путанице и усложняют поддержку кода.

Это происходит потому, что, взяв небольшой фрагмент кода, невозможно сразу понять, что происходит.
Разработчику приходится либо возвращаться к месту объявления переменной, чтобы разобраться, либо открывать исходники метода или класса.
В итоге такой код начинает выглядеть как шифровка: смотришь на него — не понимаешь, что значит каждая переменная.
Потом приходится искать «ключ», чтобы расшифровать смысл, и так по кругу.
Но мы ведь не должны заниматься разведкой.

Давайте рассмотрим следующий пример:

```php
// Плохо ❌
$usr = User::find($id);

// Хорошо ✅
$user = User::find($id);
```

Здесь переменная `$usr` представляет объект пользователя. Однако, сокращённое имя `$usr` не даёт понимания того, что именно хранится в этой переменной.

```php
// Плохо ❌
class UsrCtrl extends Ctrl {
    public function f() {
        // ...
    }
}
```

В данном примере имя класса `UsrCtrl` не информативно. Разработчику, сталкивающемуся с этим классом впервые, будет трудно понять его назначение. Название класса должно чётко отражать его функциональность, например, `ProfileController`.

```php
// Хорошо ✅
class ProfileController extends Controller
{
    public function show()
    {
        // ...
    }
}
```


В некоторых книгах по программированию можно встретить утверждения, что код должен быть самодокументируемым.
Это значит, что имена переменных, методов и классов должны объяснять, что происходит — без комментариев, без документации, без менторов.

Некоторые даже добавляют:

> «Пусть имя будет длинным, это сделает код понятнее».

Нет. Не делает.
Особенно если это имя — дымовая завеса над тем, что в коде нет ни логики, ни смысла.


Рассмотрим наглядный пример, достойный быть высеченным в граните Legacy-кода:

```php
abstract class AbstractContextHandler
{
    use SemanticMapper;

    public string $moduleScopeIdentifier = 'reporting';

    public function process(
        array $contextualizedComponentUnitPayloadArray
    ): array
    {
        $moduleScopedUnits = [];

        foreach ($contextualizedComponentUnitPayload as $contextBoundSemanticUnit) {
            $moduleScopedResponseUnits[] = $this->transformContextUnit($contextBoundSemanticUnit);
        }

        return $moduleScopedResponseUnits;
    }

    protected function transformContextUnit(
        $contextBoundSemanticUnit
    ): array
    {
        return [
            'encodedContextualPayloadFragment' => $this->map($contextBoundSemanticUnit),
            'componentUnitIntegrityChecksum' => sha1(serialize($contextBoundSemanticUnit)),
            'injectedContextualTagToken' => uniqid('module_ctx_unit_', true),
            'operationalModuleDomain' => $this->moduleNamespaceScopeIdentifier,
        ];
    }
}
```

Что делает этот класс? Не ясно.
Что он обрабатывает? Какой «контекст»? Какой «модуль»? Что за «единицы компонентов»?

Это типичный корпоративный анти-паттерн: взять простую задачу, обернуть её в кучу терминов, и сделать вид, что это архитектура.

Этот код невозможно понять. Не потому что он глупый.
А потому что этот код никогда ничего конкретного не делал.

### Конкретика 

Предыдущий пример лишен конкретики, но она может отсутствовать и в именах переменных вроде таких:

```php
// Плохо ❌
$data;
$var;
$info;
$item;
```

На первый взгляд выглядят нормально.
Но что именно в них хранится? Это может быть пользователь, список заказов или какой-нибудь внутренний флаг.
Мы не знаем, пока не залезем вглубь, что присваивается, отслеживать, как используется и даже когда мы узнаем, что такое `$data`, то в другом участке кода это может означать совершенно другое.


Это относится и к методам, иногда вполне нормально иметь метод `run` для классов которые выполняют одну единственную функцию (Так называемые Action-классы). Но это совершенно не информативно для масштабных объектов, например:

```php
// Плохо ❌
$user->run();
$user->handleData();
$user->process()
```

Старайтесь использовать информативные имена, которые отражают суть того, что они представляют, например:

```php
// Хорошо ✅
$user->posts();
$user->notify(...);
$user->deactivate();
```


### Вернут Boolean

Методы и переменные которые содержат `bool` значение, лучше всего именовать с префиксом `is/has/should`

```php
// Хорошо ✅
$isAdmin
$hasAccess
$shouldRetry
```


### Единицы измерения

Теперь давайте рассмотрим пример именования с единицами измерений

```php
// Плохо ❌
// Мы не знаем, что представляет собой число 100
$averageTime = 100;

// Хорошо ✅
// Мы понимаем что значение имеет величину 100мс
$averageTimeInMs = 100;
```

Другой способ справиться с этим — создать специальные объекты. Представьте, что вам нужно работать с процентами. Что из этого верно?

```php
// Плохо ❌
$percentage = 0.5;
$percentage = 50;
```

Встретив такую переменную, вы не сможете сказать какое значение ожидает ваше приложение.
Давайте теперь воспользуемся объектом со статическим конструктором, по одному для каждой возможности.

```php
class Percentage
{
    public static function fromInt(int $percentage): self
    {
        return new self($percentage);
    }

    public static function fromFloat(float $percentage): self
    {
        return new self($percentage * 100);
    }

    private function __construct(
        public int $value;
    ) {};
}
```

Использование класса `Percentage` поясняет, что ожидается целое число.

```php
// Хорошо ✅
$percentage = Percentage::fromFloat(0.5);
$percentage = Percentage::fromInt(50);
```

### Будьте кратки

Но не стоит пытаться расписать все длинными именами в надежде, что они ....
Давайте ровно столько информации, чтобы можно было уверенно принимать решения. Уберите все лишние слова.

Наш коллега написал, примерно такой класс, для игнорирования сущностей обширно описывая каждый метод и свойство:

```php
// Плохо ❌
class ExcludeItemStorage
{
    private ?array $excludeStorage = [];

    public function addItem(
        string $itemName,
        string $itemIdentityName,
        string $itemIdentityValue
    )
    {
        // ...
    }

    public function isItemExcluded(
        string $itemName,
        string $itemIdentityName,
        string $itemIdentityValue
    ): bool
    {
        // ...
    }

    public function unsetExcludeStorage(): void
    {
         $this->excludeStorage = null;
    }
}
```

Выглядит так как будто он прочитал несколько книжек и хочет сделать все очень понятным, но делает ровно наоборот.

Для чего нам в имени класса `Item`, как он нам помогает что либо понять? Куда сохраняются игнорируемые значения, storage это файловая система? 
У нас есть излишни описанный класс который нам не дает ни какой информации. Можно переименовать в `ExclusionList`.

А в место текущих методов предложить очень простую и дружелюбную альтернативу — краткий класс, у которого всего три понятных метода: `add`, `has` и `clear`. 
Они делают ровно то, что от них ожидаешь, и не заставляют никого слушать/читать лишние слова. 


### Использовании суффикса `-er`

В мире объектно-ориентированного программирования слишком часто встречаются имена классов вроде:

- Manager
- Controller
- Formatter
- Presenter

Эти имена плохи не потому, что они технически неверны. 
Они плохи потому, что не говорят ничего, конкретного, слишком абстрактны. 

Такая абстракция хороша для высокоуровневых концепций типа фреймворков, но не для конкретных классов в вашем приложении.

А ведь имя класса — это первый и, зачастую, единственный источник информации о его ответственности.

Эти имена — дымовая завеса. Они скрывают детали, замыливают смысл, делают код нечитаемым, а архитектуру — расплывчатой. Они подменяют суть интерфейсом, упрощая названия до абсурда. Да, это удобно. Да, так делают все. Но именно поэтому ваш проект через год превращается в груду мусора.

```php
// Плохо ❌
class ReportManager { /* … */ }
class StringFormatter { /* … */ }
```

```php
// Хорошо ✅
class StringTruncatedToLength { /* … */ }
```

Если вы не можете придумать конкретное имя — это сигнал, что саму ответственность объекта стоит пересмотреть.


### Имена тоже должны рифмоваться 

Методы в паре работают лучше, если звучат как единое целое.
Они как диалог: начало должно перекликаться с концом.

Вот пример несогласованного именования:

```php
// Плохо ❌
$object->startProcess();
$object->completeTask();
```
Методы звучат как из разных историй.
Начали процесс — закончили задачу? Лучше, если имена соответствуют:

```php
// Хорошо ✅
$object->startProcess();
$object->finishProcess();
```

или

```php
$object->beginTask();
$object->completeTask();
```
Так логика читается как пара, как вызов и отклик. 

Но это значит что ваш класс должен быть сфокусирован на одной задаче.

```php
// Хорошо ✅
$task->begin();
$task->complete();

// или
$task->start();
$task->finish();
```



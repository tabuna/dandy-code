# Магические значения

Никто не начинает изучение проекта с вдумчивого чтения всей вики.
Разработчик открывает редактор кода, запускает поиск по имени метода или класса, и — вперёд, прямо в код.
Только когда поведение становится неочевидным, когда логика не складывается — он обращается к документации, вики, базе знаний, если такая вообще есть, или, ещё хуже, к коллеге, выпрашивая информацию по чайной ложке.

<div style="page-break-after: always;"></div>

Рассмотрим классическую ситуацию:

```php
// Плохо [✗]
if ($status == 1) {
    // ...
}
```

На первый взгляд — ничего страшного. Просто проверка статуса.
Но что значит это число `1`? Почему именно оно?

Разработчик, который это писал, наверняка знает, что `1` здесь означает "активный статус".
Но для всех остальных — это магическое число, появившееся из ниоткуда.
Код превращается в загадку: *почему не `0`? А может быть ли значение `2`? А в статус приходит `1` или `true`?*

Теперь представьте, что этот код читает кто-то вроде меня — из мира Linux.
В Unix-системах код `0` означает успешное завершение, а `1` — **ошибку**.
И я интуитивно читаю этот код иначе: *"О, тут проверяется, что была ошибка?"*
Мои привычки вступают в конфликт с чужими соглашениями — и я начинаю сомневаться в логике самого кода.

А если значение гораздо больше, например:

```php
// Плохо [✗]
if ($status == 24) {
    // ...
}
```

Что это значит? День рождения начальника? Номер ошибки? Идентификатор тайного соглашения?

Загадочными могут быть не только числа. Иногда код может притаить за собой набор символов:

```php
// Плохо [✗]
if ($char === '%!') {
    // ...
}
```

Что значит `%!`? Если значение несёт смысл, пусть оно громко заявляет о себе именем. Тогда станет ясно, зачем оно здесь и как его использовать дальше с помощью константы:

```php
// Хорошо [✓]
const STATUS_ACTIVE = 1;

if ($status === STATUS_ACTIVE) {
    // ...
}
```

Теперь код стал более понятным и поддерживаемым.
При его чтении сразу становится понятно, что проверяется в условии.

<div style="page-break-after: always;"></div>

Можно пойти дальше и использовать перечисления для явного определения различных значений:

```php
// Хорошо [✓]
enum Status: string
{
    case ACTIVE = 'active';
    case INACTIVE = 'inactive';
    case ARCHIVED = 'archived';
}

if ($status === Status::ACTIVE) {
    // ...
}
```

Или числовым значением:

```php
// Хорошо [✓]
enum Status: int
{
    case ACTIVE = 1;
    case INACTIVE = 2;
    case ARCHIVED = 3;
}

if ($status === Status::ACTIVE) {
    // ...
}
```

Такой подход делает код более читаемым и позволяет явно указать доступные значения статуса и использовать как типизированное значение в методах, например:

```php
function canBePublished(Status $status): bool
{
    // ...
}
```

Используя именованные константы или перечисления, мы делаем код более понятным и поддерживаемым, ведь нам не нужно обращаться ни к документации, ни к коллеге за прояснениями, что важно для разработки масштабируемых приложений.


### Переизбыток констант

Когда речь заходит о «магических значениях», первый инстинкт многих начитанных только первой частью разработчиков — немедленно заменить каждое из них на именованную константу.
Как было показано ранее, это логично, но не всегда разумно. Проблема не в самих константах, а в том, как читается код и насколько понятна его суть.

Рассмотрим реальный пример:

```php
// Плохо [✗]
class Order
{
    public function daysSinceLastUpdate(): float
    {
        return $this->updated_at / 1_000_000 / 60 / 60 / 24;
    }
}
```

Здесь мы видим цепочку арифметических операций, и каждый разработчик, читающий этот код, вынужден мысленно раскручивать её:
 «Так, это микросекунды, потом секунды, потом минуты... ага, значит это перевод времени в дни».
Это усложняет чтение и отвлекает от сути метода.

После слепого ввода многочисленных констант пример начинает выглядеть так:

```php
// Плохо [✗]
class Order
{
    private const MICROSECONDS_IN_SECOND = 1_000_000;
    private const SECONDS_IN_MINUTE = 60;
    private const MINUTES_IN_HOUR = 60;
    private const HOURS_IN_DAY = 24;

    public function daysSinceLastUpdate(): float
    {
        return $this->updated_at
            / self::MICROSECONDS_IN_SECOND
            / self::SECONDS_IN_MINUTE
            / self::MINUTES_IN_HOUR
            / self::HOURS_IN_DAY;
    }
}
```

Формально — код стал «говорящим». Но читается он по-прежнему тяжело. Мы заменили магию чисел на большое количество деталей.

<div style="page-break-after: always;"></div>

Вместо того чтобы «расшифровывать» механику времени вручную, лучше полностью передать заботу об этом классу, который создан именно для этой работы.
Например, `Carbon`:

```php
// Хорошо [✓]
use Carbon\Carbon;

class Order
{
    public function daysSinceLastUpdate(): float
    {
        return Carbon::create($this->updated_at)
            ->floatDiffInDays(now());
    }
}
```

Не всякое «магическое значение» нужно заменять на константу. Иногда **лучший способ устранить магию — не объяснять детали вообще**. Спрячьте реализацию за выразительным интерфейсом. Пусть код говорит что он делает, а не как.

Ещё лучше будет, если наши свойства сразу будут объектами:

```php
// Хорошо [✓]
class Order
{
    public function daysSinceLastUpdate(): float
    {
        return $this->updated_at->floatDiffInDays(now());
    }
}
```

Если кажется, что время слишком простой пример, то вот похожий с размером файла:

```php
// Плохо [✗]
class File
{
    public function humanReadableSize(): string
    {
        return $this->size / 1024 / 1024 . ' MB';
    }
}
```

Для которого добавили константы:

```php
// Плохо [✗]
class File
{
    private const SHORT_MEGABYTE = 'MB';
    private const BYTES_IN_MEGABYTE = 1024 * 1024;

    public function humanReadableSize(): string
    {
        $megabytes = $this->size / self::BYTES_IN_MEGABYTE;

        return sprintf(
            '%.2f %s',
             $megabytes,
             self::SHORT_MEGABYTE
        );
    }
}
```

Вместо таких констант лучше всего делать классы, которые будут скрывать все эти вычисления.
К тому же они сразу же будут переиспользованы в вашем проекте в других местах, чем вводить новые приватные константы или, ещё хуже, объявлять публичными у `File` и ещё больше увеличивать связность.


```php
// Хорошо [✓]
class File
{
    public function humanReadableSize(): string
    {
        return $this->size->toHumanReadable();
    }
}

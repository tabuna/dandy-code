# Магические значения

Никто не начинает изучение проекта с вдумчивого чтения всей вики. 
Разработчик открывает IDE, запускает поиск по имени метода или класса, и — вперёд, прямо в код. 
Только когда поведение становится неочевидным, когда логика не складывается — он обращается к документации, вики, базе знаний если такая вообще есть или еще хуже к коллеге выпрашивая информацию по чайной ложке.

Рассмотрим классическую ситуацию:

```php
// Плохо ❌
if ($status == 1) {
    // ...
}
```

На первый взгляд — ничего страшного. Просто проверка статуса.
Но что значит это число `1`? Почему именно оно?

Разработчик, который это писал, наверняка знает, что `1` здесь означает "активный статус".
Но для всех остальных — это магическое число, появившееся из ниоткуда.
Код превращается в загадку: *почему не `0`? А может быть ли значение `2`? А в статус приходит `1` или `true`?*

Теперь представьте, что этот код читает кто-то вроде меня — из мира Linux.
В Unix-системах код `0` означает успешное завершение, а `1` — **ошибку**.
И я интуитивно читаю этот код иначе: *"О, тут проверяется, что была ошибка?"*
Мои привычки вступают в конфликт с чужими соглашениями — и я начинаю сомневаться в логике самого кода.

А если значение гораздо больше, например:

```php
// Плохо ❌
if ($status == 24) {
    // ...
}
```

Что это значит? День рождения начальника? Номер ошибки? Идентификатор тайного соглашения?

Загадочными могут быть не только числа. Иногда код может притаить за собой набор символов:

```php
// Плохо ❌
if ($char === '%!') {
    // ...
}
```

Что значит `%!`? Если значение несёт смысл, пусть оно громко заявляет о себе именем. Тогда станет ясно, зачем он здесь и как его использовать дальше с помощью константы:

```php
// Хорошо ✅
const STATUS_ACTIVE = 1;

if ($status === STATUS_ACTIVE) {
    // ...
}
```

Теперь код стал более понятным и поддерживаемым. 
При его чтении сразу становится понятно, что проверяется в условии.

Можно пойти дальше ещё дальше и использовать перечисления для явного определения различных значений:

```php
// Хорошо ✅
enum Status: string
    case ACTIVE = 'active';
    case INACTIVE = 'inactive';
    case ARCHIVED = 'archived';
}

$status = Status::ACTIVE;

if ($status === Status::ACTIVE) {
    // ...
}
```

```php
// Хорошо ✅
enum Status: int
    case ACTIVE = 1;
    case INACTIVE = 2;
    case ARCHIVED = 3;
}

$status = Status::ACTIVE;

if ($status === Status::ACTIVE) {
    // ...
}
```

Такой подход делает код более читаемым и позволяет явно указать доступные значения статуса и использовать как типизированное значение в методах, например:

```php
function canBePublished(Status $status): bool
{
    // ...
}
```

Используя именованные константы или перечисления, мы делаем код более понятным и поддерживаемым, ведь нам не нужно обращаться ни к документации, ни к коллеге, за прояснениями, что важно для разработки масштабируемых приложений.


### Переизбыток констант

Когда речь заходит о «магических значениях», первый инстинкт многих начитанных только первой частью разработчиков — немедленно заменить каждое из них на именованную константу. 
Как было показано ранее, это логично, но не всегда разумно. Проблема не в самих константах, а в том, как читается код и насколько понятна его суть.

Рассмотрим реальный пример:

```php
// Плохо ❌
class Order
{
    // ...

    public function daysSinceLastUpdate(): float
    {
        return (((($this->lastUpdatedAt / 1_000_000) / 60) / 60) / 24);
    }
}
```

Здесь мы видим цепочку арифметических операций, и каждый разработчик, читающий этот код, вынужден мысленно раскручивать её:
 «Так, это микросекунды, потом секунды, потом минуты... ага, значит это перевод времени в дни». 
Это усложняет чтение и отвлекает от сути метода.


После слепого ввода констант пример начинает выглядеть так:
```php
// Плохо ❌
class Order
{
    private const MICROSECONDS_IN_SECOND = 1_000_000;
    private const SECONDS_IN_MINUTE = 60;
    private const MINUTES_IN_HOUR = 60;
    private const HOURS_IN_DAY = 24;

    public function daysSinceLastUpdate(): float
    {
        return $this->lastUpdatedAt
            / self::MICROSECONDS_IN_SECOND
            / self::SECONDS_IN_MINUTE
            / self::MINUTES_IN_HOUR
            / self::HOURS_IN_DAY;
    }
}
```

Формально — код стал «говорящим». Но читается он по-прежнему тяжело. Мы заменили магию чисел на магическое количество деталей,

Вместо того чтобы «расшифровывать» механику времени вручную, лучше полностью передать заботу об этом классу, который создан именно для этой работы. 
Например, `Carbon`:

```php
// Хорошо ✅
use Carbon\Carbon;

class Order
{
    public function daysSinceLastUpdate(): float
    {
        return Carbon::create($this->lastUpdatedAt)
            ->floatDiffInDays(now());
    }
}
```

Не всякое «магическое значение» нужно заменять на константу. Иногда **лучший способ устранить магию — не объяснять детали вообще**. Спрячьте реализацию за выразительным интерфейсом. Пусть код говорит что он делает, а не как.

Еще лучше, будет если наши свойства будут не примитивные данные, а сразу объекты, тогда:

```php
// Хорошо ✅
class Order
{
    public function daysSinceLastUpdate(): float
    {
        return $this->lastUpdatedAt->floatDiffInDays(now());
    }
}
```

Если кажется, что время слишком простой пример, то вот похожий с размером файла:

```php
// Плохо ❌
class File
{
    public function humanReadableSize(): string
    {
        $megabytes = $this->sizeInBytes / 1024 / 1024;

        return number_format($megabytes, 2) . ' MB';
    }
}
```

Для которого добавили константы:

```php
// Плохо ❌
class File
{
    private const SHORT_MEGABYTE = 'MB';
    private const BYTES_IN_KILOBYTE = 1024;
    private const KILOBYTES_IN_MEGABYTE = 1024;

    public function humanReadableSize(): string
    {
        $megabytes = $this->size
            / self::BYTES_IN_KILOBYTE
            / self::KILOBYTES_IN_MEGABYTE;

        return sprintf(
            '%.2f %s', 
            $megabytes,
            self::SHORT_MEGABYTE
        );
    }
}
```

Вместо таких констант, лучше всего делать классы которые будут скрывать все эти вычисления. 
К тому же они сразу же будут переиспользованы в вашем проекте в других местах, чем вводить новые приватные константы или еще хуже объявлять публичными у `File` и еще больше увеличивать связность.


```php
// Хорошо ✅
use DataSize;

class File
{
    public function humanReadableSize(): float
    {
        return $this->size->toHumanReadable();
    }
}
```

# Размер имеет значение

В детстве мы играли в простую, но удивительно поучительную игру. 
Дети становились в круг, и один из них начинал перекидывать мяч. 
Но это был не просто мяч — это была «горячая картошка». 
И правила были предельно ясны: поймал — тут же бросай дальше. 
Максимум одна секунда. Кто задержал — проиграл. 
Никаких пауз, планов и стратегий. Только действие. Только передача.

Если ты хоть на мгновение задумался — обжёгся. 
Ты должен доверять интуиции, не копаться в себе и не мешать движению игры.

Так и с кодом. Каждый класс, каждый метод, каждая строка — это не долгий монолог, а быстрый пас, моментальный результат, передача задачи следующему игроку. Код не должен «держать мяч» в руках подолгу, копаться в себе, раздувать внутренние сложности, мешать движению.

У каждого должна быть одна цель — передать задачу и не тормозить процесс. 
Ассоциируйте это как:

- Класс — это игрок.
- Метод — это пас. Он может быть левой рукой, правой, можно схватить или отбросить мяч.
- Строки — это момент перед броском.


Когда момент перед пасом выглядит вот так:

```php
// Слишком длинный метод ❌
public function export(string $key) 
{
    // ...
    // ...
    // 1000 строк кода

    return $result;
}
```

То получается, что игрок ловит мяч и... 
Он ловит мяч и… не бросает. Он встал посреди круга и начал делать кувырки, включил музыку, рассказал стихотворение и только потом — спустя долгие секунды — наконец передал мяч дальше.

Это раздражает не только других игроков при игре, ведь тоже самое происходит с кодом, когда его размер выходит за разумные пределы. 
Длинные методы и классы начинают запутывать, а вместо ясности мы получаем неразбериху, с которой сложно работать. 

Точно так же, как перегруженные предложения, огромные блоки кода перегружают восприятие. Читая их, трудно понять, о чём конкретно идёт речь, и приходится возвращаться к началу, чтобы разобраться, что вообще происходит.

Худшие разработчики будут гордиться таким кодом и говорить, да он сложный, да он умный, да он крутой. Но на самом деле это просто неумение передать мяч как можно быстрее.
Некоторые разработчики пытаются исправить проблему, формально дробя код на отдельные методы:

> TODO Sprout Method! Проблема: метод перегружен и зависит от всего.
```php
// Слишком длинный метод ❌
public function export(string $key) 
{
    // Загрузка данных
    // Валидация
    // Преобразование
    // Генерация отчёта
    // Сохранение в файл
    // Отправка по почте
    // И ещё десяток шагов...
    $this->step();
    $this->step();
    $this->step();
    
    $this->load();
    $this->validate();
    $this->transform();
    $this->generateReport();
    // И ещё десяток шагов...
    $this->sendMail();

    return $result;
}
```

На первый взгляд — красиво, ведь метод `export()` в записан условно в пять строчек. 
Но где тут само «сердце»? Вам приходится прыгать из метода в метод, искать смысл: «а, здесь что-то подгружается, а вот здесь валидируется, а вот здесь ещё что-то происходит…». 
Получается эффект «многостёковой передачной паутины»: глаз бегает по коду без чувства завершённости.

Правильно дробить — значит давать каждому этапу собственную осмысленную ответственность, а не делать «пустую оболочку» ради экономии строк. 
Если метод публичный, он должен отражать высокоуровневый шаг, понятный «с первого взгляда». А приватные методы должны решать действительно отдельный логический блок, а не просто «задёргивать» следующий вызов без собственной логики.

Хороший публичный метод должен вызывать у вас реакцию: «Да, это целостный шаг!» Например:

```php
// Хорошо ✅
$document = Document::find(1);

$content = $document->export(Excel::class);

$user->notify(ExportNotification::class, [
    'content' => $content->toString(),
]);
```

Каждая строка — как законченный абзац.
Здесь нет прыжков по стеку.
Всё перед глазами и мы наглядно видим, что сделали пас. 


Но даже когда мы избавились от процедурного стиля "шаг1","шаг2","шаг3" очень легко попасть в ловушку 
о том кто должен принимать решения? И в какой форме объекты должны взаимодействовать друг с другом?

Например:

```php
// Плохо ❌ 
$document = Document::find(1);

if($document->isPublished()) {
    $content = $document->export(Excel::class);
}
```

В этом примере, мы спрашиваем у объекта какие-то данные, а затем на основе этих данных принимаешь решение — ты, по сути, берёшь
на себя его ответственность. Вместо этого пусть внутри метода будет выброшено исключение или выполнено другое поведение, но 

Пусть объект сам разберётся, с кем и как ему взаимодействовать. Ты только описываешь намерение. Это делает архитектуру
более модульной и гибкой.

```php
// Плохо ❌
if ($user->isAdmin() || $user->hasRole('manager')) {
    $content = $document->export(Excel::class);
}
```

```php
// Хорошо ✅
if ($user->canExport($document)) {
    $content = $user->export(Excel::class);
}
```

Это один из важных принципов, который помогает сделать код объектов лаконичными, звучит так:

> Не спрашивай объект о его данных, чтобы принять решение — скажи объекту, что делать.


Игра «горячая картошка» научила нас — не задерживать ответственность. А принцип гооврить ...
В следующих разделах разберём конкретные техники, которые позволяют быстрее передать «мяч» дальше.
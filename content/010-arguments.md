# Аргументы

### Чем меньше, тем лучше

Методы с большим числом аргументов сложнее читать, тестировать и использовать.
**Правило трёх**: метод не должен принимать больше **трёх параметров**. Если больше — разделите.

```php
// Плохо ❌
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    true,                        // Перезаписать файл, если он существует
    'Пример данных для записи.', // Содержимое
    'UTF-8',                     // Кодировка
    true                         // Включаем логирование
);
```

Если у метода четыре, пять, а то и шесть параметров — становится сложно понять, что есть что, в каком порядке это передавать, и как вообще это использовать. Особенно это усугубляется когда имена аргументов очень похожи.

Даже если вы напишете великолепный комментарий перед методом, человек читающий код будет вынужден каждый раз к нему возвращаться.

### Необязательные аргументы — в конец

При проектировании методов порядок аргументов имеет значение. 
Один из самых простых и эффективных способов сделать его чище — располагать необязательные параметры в конце.

Рассмотрим пример:
```php
// Плохо ❌
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    null,                        // Перезаписать файл, если он существует
    'Пример данных для записи.', // Содержимое
);
```
Чтобы просто записать файл, нам приходится явно указывать `null` — значение, которое на самом деле нам не нужно.

Куда лучше такой вариант:

```php
// Хорошо ✅
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    'Пример данных для записи.', // Содержимое
);
```

А если нужно изменить поведение по умолчанию, мы просто добавим третий параметр:

```php
// Плохо ❌
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    'Пример данных для записи.', // Содержимое
    true,                        // Перезаписать файл, если он существует
);
```

В этом случае метод будет принимать только обязательные параметры, а необязательные будут в конце. Это делает код чище и понятнее. Так как их можно не указывать, если они не нужны.

### Как поступить, если аргументов много?

Иногда метод требует не один-два, а сразу пять или больше параметров. Передавать всё списком в строго заданном порядке — не лучшая идея. Легко перепутать аргументы, особенно если они одного типа. К тому же вызов такого метода выглядит пугающе и плохо читается.

Первое, что приходит на ум это использование ассоциативного массива:

```php
// Плохо ❌
$fileSystem->write(
    '/path/to/file.txt',
    'Пример данных для записи.',
    [
        'encoding' => 'UTF-8',
        'overwrite' => true,
        'debug' => true,
    ]
);
```

Это отвратительный способ. Такой подход не даёт информации о том, какие параметры действительно ожидаются, и не позволяет IDE подсказывать возможные опции. Более того, здесь нет проверки типов — любые ошибки проявятся только во время выполнения. Это усложняет отладку и увеличивает вероятность багов.

Другая популярная попытка — создать объект, инкапсулирующий значения. Например:

```php
$config = new Config($encoding, $overwrite, $debug);

// Пример использования
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    null,                        // Перезаписать файл, если он существует
    $config,                     //
);
```

Это лишь видимость решения. Мы создали объект, который сам по себе бессмысленен: он не содержит поведения и не добавляет никакой бизнес-логики. Фактически, это тот же массив, только завернутый в класс. Польза от него — разве что автодополнение в IDE. Но теперь мы должны создавать или таскать этот объект везде, где вызываем метод `write`, что только усложняет код.


Если язык поддерживает именованные аргументы и их количество очень-очень ограничено, стоит использовать их:
```php
$fileSystem->write(
    '/path/to/file.txt',
    'Пример данных для записи.',
    debug: true, // Именованный параметр
);
```
Это уже лучше: вызов становится самодокументируемым, и порядок аргументов не имеет значения.

В случае языков с поддержкой именованных аргументов, можно использовать их:

```php
$fileSystem->write(
    '/path/to/file.txt',
    'Пример данных для записи.',
    debug: true,  // Именованный параметр
);
```

Но есть гораздо более выразительный и управляемый способ — **fluent-интерфейс**. 
Это объект, методы которого возвращают самого себя, позволяя вызывать их цепочкой:

```php
// Хорошо ✅
$fileSystem
    ->path('/path/to/file.txt')
    ->encoding('UTF-8')
    ->overwrite(true)
    ->debug(true)
    ->write('Пример данных для записи.');
```

В этом подходе сразу видно, что происходит. Каждый шаг отделён, названия методов описывают действия, и вся цепочка читается как связный набор настроек. Такой стиль легко расширяется, хорошо покрывается тестами и открывает дорогу к более гибкой архитектуре.

### Предпочитайте объекты

Строки, булевые, числа очень удобны в начале разработки, но с течением времени, логика усложняется, и эти простые значения не справляются.

Что раньше было флагом `true`, теперь требует дополнительных условий:
*если админ*, *если включён режим отладки*, *если пользователь подтвердил e-mail*.

Скалярные значения не умеют расти. Они не подстраиваются под новые требования.
А объект — может. Он расширяется методами, валидирует себя, хранит контекст и смысл.

Возьмем ранее расмотренный пример из предыдущей главы про игнорируемый список, который мы уже немного улучшили:

```php
// Плохо ❌
class ExcludeList
{
    private array $$list = [];

    public function add(string $itemName, string $itemIdentityName, string $itemIdentityValue): void
    {
        // ...
    }

    public function has(string $itemName, string $itemIdentityName, string $itemIdentityValue): bool
    {
        // ...
    }

    public function clear(): void
    {
         $this->list = [];
    }
}
```

Вместо того чтобы передавать несколько строковых значений, можно использовать уже существующий объект или создать новый, который сам решит, как обработать добавление и поиск элемента:

```php
// Хорошо ✅
class ExcludeList
{
    private array $$list = [];

    public function add(Model $model): static
    {
        $key = $model->getKey();
        // ...
    }

    public function has(Model $model): bool
    {
        $key = $model->getKey();
        // ...
    }

    public function clear(): static
    {
         $this->list = [];

         return $this;
    }
}
```

Теперь метод `add` и метод `has` работают с объектами, а не с простыми значениями. 
Это упрощает добавление новых параметров и изменений в модель, не затрагивая логику работы методов, а также облегчает тестирование.



TODO: Раздел `Предпочитайте обьекты` конфликтует с `Как поступить, если аргументов много?`

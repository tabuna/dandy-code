# Без лишних движений

Что отличает настоящего мастера от любителя?
Не скорость или количество работы, а умение делать только то, что действительно нужно — без лишних действий, без
излишних усложнений.

Лишние операции съедают время, отвлекают от сути и увеличивают вероятность ошибок.
Настоящий мастер знает: чем меньше шагов, тем меньше точек отказа и тем проще менять и улучшать код.

### Не создавай переменные без необходимости

Каждая переменная — это дополнительный элемент, который надо держать в голове и читать.
Если переменная не улучшает читаемость и не нужна для повторного использования, от неё стоит отказаться.

```php
// Плохо [✗]
$tmp = $user->name;
echo $tmp;
```

В этом примере переменная `$tmp` не даёт никакой дополнительной пользы: она лишь усложняет код добавляя лишнее имя,
которое нужно запомнить.

```php
// Хорошо [✓]
echo $user->name;
```

Прямой вывод значения из объекта будет проще и понятнее.

### Не меняй тип данных для переменной

Переменная может легко поменяться, это заложено в самом определении переменной, но смена типа в процессе её жизни
означает, что код плохо структурирован.
Это снижает предсказуемость и усложняет отладку кода.

```php
// Плохо [✗]
function (array $user) {
    $user = new User($user);  // Был массив, стал объект
}
```

Но если оказались в такой ситуации, намного лучше будет уточнить и дать другое имя:

```php
// Хорошо [✓]
function (array $userData) {
    $user = new User($userData);
}
```

Лучше всего сразу работать с объектами и при необходимости — извлекать из них нужные данные, например, преобразовывать в
массив:

```php
// Хорошо [✓]
function (User $user) {
   // ...
}
```

Особенно часто такое изменение можно заметить с переменными `$value`, `$item` и `$result`, когда конечный результат
меняется:

```php
// Плохо [✗]
$value = [1, 2, 3];         // массив
$value = (object) $value;   // теперь объект
$value = json_encode($value); // теперь строка
```

### Избегай повторных вычислений

Если результат операции нужен несколько раз, лучше вычислить его один раз и сохранить в переменную, чем повторять
вычисления.
Это особенно важно внутри циклов и условий: лишний вызов метода или обращение к внешнему ресурсу может стоить дорого.

```php
// Плохо [✗]
foreach ($users as $user) {
    $moon = MoonPhase::forToday();
    
    $user->notify(new MoonPhaseNotification($moon));
}
```

Метод `MoonPhase::forToday()` вызывается на каждой итерации, хотя результат каждый раз одинаковый. В реальной жизни этот
метод может обращаться к внешнему API или выполнять тяжёлые вычисления.

```php
// Плохо [✗]
foreach ($users as $user) {
    $moon ??= MoonPhase::forToday();

    $user->notify(new MoonPhaseNotification($moon));
}
```

Этот способ вызова метода выполнится только один раз, но может быть неочевиден для неподготовленного читателя.
Оператор `??=` (null coalescing assignment) означает: «если переменная `$moon` ещё не определена или равна `null`,
присвой ей значение».
Хотя это удобно, внутри цикла такая запись может восприниматься как «магия» — к тому же важно помнить, что переменная с
таким именем не должна быть объявлена ранее.
Чтобы избежать недопониманий, лучше сделать намерение явным:

```php
// Хорошо [✓]
$moon = MoonPhase::forToday();

foreach ($users as $user) {
    $user->notify(new MoonPhaseNotification($moon));
}
```

Сохранение результата в переменную делает код не только читаемее, но и предсказуемее.

<div style="page-break-after: always;"></div>

### Используй подходящие структуры данных

Выбирайте правильную структуру данных с самого начала, чтобы не пришлось преобразовывать и адаптировать её в процессе.
Часто начинают с базовых типов, например, хранение данных в массивах кажется очень заманчивым и удобным решением: можно
просто взять нужное значение по ключу.
Но затем в коде начинают появляться конструкции вроде:

```php
// Плохо [✗]
if (isset($user['address']['city'])) {
    $city = $user['address']['city'];
} else {
    $city = 'Неизвестно';
}
```

Сначала это кажется безобидным.
Но когда таких вложенных ключей становится много, и данные разбросаны по всему коду, всё усложняется.
Вместо того, чтобы описывать логику поведения, мы продолжаем манипуляции с данными на низком уровне.
Чтобы получить ещё одно значение, снова и снова приходится писать `isset` с длинной цепочкой:

```php
// Плохо [✗]
if (
    isset($user['address']['city']) &&
    isset($user['preferences']['language'])
) {
    $city = $user['address']['city'];
    $language = $user['preferences']['language'];
}
```

Такая практика раскрывает детали хранения данных во всех местах их использования и делает код процедурным: каждый шаг
работы с «сырыми» данными прописывается вручную, вместо того чтобы описать желаемое поведение

Например, фильтрация заказов пользователя по городу при использовании массивов выглядит так:

```php
// Плохо [✗]
if (isset($user['id'], $user['address']['city'])) {
    $city = $user['address']['city'];

    $userOrders = array_filter(
        $orders,
        function ($order) use ($user, $city) {
            return $order['user_id'] === $user['id']
             && $order['city'] === $city;
        }
    );
} else {
    $userOrders = [];
}
```

Здесь постоянно приходится повторять проверки и раскрывать детали — где у пользователя лежит город, как устроен заказ.
Если структура данных изменится, код придётся менять во многих местах. Это сложно и рискованно.
Использование объектов и инкапсуляция данных позволяют скрыть детали и упростить взаимодействие:

```php
// Хорошо [✓]
$city = $user->address?->city() ?? 'Неизвестно';
$language = $user->preferences?->language ?? 'ru';
```

Код становится линейным и более читаемым, а изменения внутренней структуры данных требуют правок только внутри
соответствующих классов.

Для полного устранения проверок на `null` можно применить паттерн `Null Object` — объект-заглушку, возвращающий значения
по умолчанию, что дополнительно упрощает код:

```php
// Хорошо [✓]
class NullAddress {
    public function city()
    {
        return 'Неизвестно';
    }
}

$city = $user->address->city();
```

Если же продолжать использовать массивы с `isset` повсюду, проект превратится в спагетти из проверок и длинных цепочек
ключей.
Это затруднит чтение и увеличит количество ошибок — они всегда рядом там, где много ручных проверок.

> {notice} Паттерн `Null Object` полезен не только для возврата значений по умолчанию, но и для реализации методов,
> которые
> не должны выполнять никаких действий.



Даже для простых типов данных — строк и чисел — стоит использовать объекты.
Мы уже ранее рассматривали пример класса `Temperature`, который скрывает от нас работу с единицами измерения.
Теперь рассмотрим аналогичный подход на примере строк.

Часто обработку строки записывают через вложенные вызовы:
```php
// Плохо [✗]
echo strtoupper(trim(substr($input, 0, 10)));
```

Код работает, но превращается в «матрёшку» из-за их чрезмерного количества вложенных функций.
Читать его приходится справа налево, что совсем не свойственно латинице, на которой мы пишем код.
Это увеличивает когнитивную нагрузку и скрывает намерение.

Для чтения удобнее сделать класс:

```php
// Хорошо [✓]
class Text implements Stringable {
    public function __construct(private string $value) {}

    public function cut(int $length): static 
    {
        return new static(substr($this->value, 0, $length));
    }

    public function trim(): static 
    {
        return new static(trim($this->value));
    }

    public function value(): string 
    {
        return $this->value;
    }

    // ...
}
```

С таким классом обработка становится читаемой и выразительной:

```php
echo (new Text($input))
    ->cut(10)
    ->trim()
    ->upper()
    ->value();
```

Теперь мы читаем цепочку шагов, а не пытаемся расшифровать вложенные функции.

> **Обратите внимание на иммутабельность.**
> Каждый шаг возвращает новый объект при котором не будет скрытых побочных эффектов.


### Ссылки делают код хрупким

Передавать переменную по ссылке кажется удобным: функция сразу меняет её — меньше кода, меньше присваиваний.
Вот пример:

```php
// Плохо [✗]
function celsiusToFahrenheit(float &$celsius): void
{
    $celsius = $celsius * 9 / 5 + 32;
}

$temp = 25;
celsiusToFahrenheit($temp);
echo $temp; // 77 — значение изменилось «внутри» функции
```

На первый взгляд это экономия кода, но есть подвох: после вызова функции уже не понятно, изменится переменная или нет.
Изменения происходят «за кадром», что усложняет чтение и поддержку кода.

Из-за этого код становится хрупким — любое забытое или неожиданное изменение может сломать логику программы.

Лучшей практикой считается писать функции, которые принимают значение и возвращают новый результат, не изменяя исходные
данные:

```php
// Хорошо [✓]
function celsiusToFahrenheit(float $celsius): float
{
    return $celsius * 9 / 5 + 32;
}


$temp = 25;
$tempInFahrenheit = celsiusToFahrenheit($temp);
echo $temp; // 25 — значение не изменилось
```

Такой код прозрачный и предсказуемый: переменные не меняются «вдруг», а результат возвращается явно и используется там,
где нужно.

### Место для расширения

Иногда нужно немного изменить поведение класса — добавить одно условие, поменять одну строчку, подставить другую
функцию. Казалось бы, мелочь, но уже появляются соблазны.

Часто мы думаем: «Создам новый класс, унаследуюсь от старого и переопределю нужный метод». Быстро, просто и вроде
аккуратно.

Например, есть простой класс который группирует новостные сводки погоды по городам:

```php
$news = [
    "В Москве температура побила рекорд 2013 года",
    "В Москве жарко и солнечно",
    "В Липецке дожди идут без остановки",
    "В Липецке на этой неделе дождливая погода",
];

$grouper = new NewsGrouper($news); 
// ['Москва' => [...], 'Липецк' => [...]]
```

И нужно изменить алгоритм сравнения двух заголовков.
Часто мы думаем: «Создам новый класс, унаследуюсь от старого и переопределю нужный метод». Быстро, просто и вроде
аккуратно.

Например, так:

```php
class NewsGrouperBySimilarText extends NewsGrouper
{
    protected function similar(string $a, string $b): bool
    {
        similar_text($a, $b, $percent);

        return $percent > 51;
    }
}
```

<div style="page-break-after: always;"></div>

А затем еще один:

```php
class NewsGrouperBySoundex extends NewsGrouper
{
    protected function similar(string $a, string $b): bool
    {
        return soundex($a) === soundex($b);
    }
}
```

На первый взгляд — разумно. Но через месяц таких потомков будет уже пять, потом десять.
Затем понадобится изменить в части наследников нормализацию имен для городов. Кто-то добавит изменения в
родительский класс, чтобы «не трогать потомков» — и структура начинает шататься.

Вы смотрите на этот зоопарк и задаётесь вопросом: где живёт нужная логика? В родителе? В потомке? В обоих? В каком из
пятнадцати классов?

Всё стало сложнее, чем было. Хотя вы просто хотели добавить одно небольшое изменение.

Почему так происходит? Потому что в коде нет места для изменений без разрушений. Нет точки расширения — шва (seam). В
результате единственный способ изменить поведение — наследование, переопределение и копипастинг.

Вместо наследования можно сделать в классе точку расширения — шов, который позволяет изменить поведение без правки
существующего кода. Например, передать колбэк или другой объект. Главное — не трогать внутренности класса, всё меняется
снаружи.

Простой пример:

```php
class NewsGrouper {
    public function groupBy(callable $similar): static {
       $this->similar = $similar;
       
       return $this;
    }
}
```

Теперь вы определяете, как именно форматировать отчёт:

```php
$grouper = new NewsGrouper($news);
$grouper->groupBy(function (string $a, string $b): bool {
    similar_text($a, $b, $percent);

    return $percent > 51;
});
```

Никаких наследников. Всё поведение — в одном месте. Тестировать такой класс легко, расширять — ещё проще.

Когда его будет недостаточно или он разрастётся, замените `callable` на интерфейс и передавайте объект, реализующий его.

```php
$grouper = new NewsGrouper($news);
$groups = $grouper->groupBy(new SimilarComparator());
```

Идея очень проста:
Не спешите писать `extends`.
Спросите себя: можно ли здесь оставить шов?
Если да — вы только что сделали код гибче, проще и чище.
# Без лишних движений

Что отличает настоящего мастера от любителя?
Не скорость или количество работы, а умение делать только то, что действительно нужно — без лишних действий, без
излишних усложнений.

Лишние операции съедают время, отвлекают от сути и увеличивают вероятность ошибок.
Настоящий мастер знает: чем меньше шагов, тем меньше точек отказа и тем проще менять и улучшать код.

### Не создавайте переменные без необходимости

Каждая переменная — это дополнительный элемент, который надо держать в голове и читать.
Если переменная не улучшает читаемость и не нужна для повторного использования, от неё стоит отказаться.

```php
// Плохо [✗]
$tmp = $user->name;
echo $tmp;
```

В этом примере переменная `$tmp` не даёт никакой дополнительной пользы: она лишь усложняет код добавляя лишнее имя,
которое нужно запомнить.

```php
// Хорошо [✓]
echo $user->name;
```

Прямой вывод значения из объекта будет проще и понятнее.

### Не меняйте тип данных для переменной

Переменная может легко поменяться, это заложено в самом определении переменной, но смена типа в процессе её жизни
означает, что код плохо структурирован.
Это снижает предсказуемость и усложняет отладку.

```php
// Плохо [✗]
function (array $user) {
    $user = new User($user);  // Был массив, стал объект
}
```

Но если оказались в такой ситуации, намного лучше будет уточнить и дать другое имя:

```php
// Хорошо [✓]
function (array $userData) {
    $user = new User($userData);
}
```

Лучше всего сразу работать с объектами и при необходимости — извлекать из них нужные данные, например, преобразовывать в массив:

```php
// Хорошо [✓]
function (User $user) {
   // ...
}
```

Особенно часто такое изменение можно заметить с переменными `$value`, `$item` и `$result` когда конечный результат меняется:

```php
// Плохо [✗]
$value = [1, 2, 3];         // массив
$value = (object) $value;   // теперь объект
$value = json_encode($value); // теперь строка
```

### Избегайте повторных вычислений

Если результат операции нужен несколько раз, лучше вычислить его один раз и сохранить в переменную, чем повторять
вычисления.
Это особенно важно внутри циклов и условий: лишний вызов метода или обращение к внешнему ресурсу может стоить дорого.

```php
// Плохо [✗]
foreach ($users as $user) {
    $moon = MoonPhase::forToday();
    
    $user->notify(new MoonPhaseNotification($moon));
}
```

Метод `MoonPhase::forToday()` вызывается на каждой итерации, хотя результат каждый раз одинаковый. В реальной жизни этот
метод может обращаться к внешнему API или выполнять тяжёлые вычисления.


```php
// Плохо [✗]
foreach ($users as $user) {
    $moon ??= MoonPhase::forToday();

    $user->notify(new MoonPhaseNotification($moon));
}
```

Этот способ вызова метода выполнится только один раз, но может быть неочевиден для неподготовленного читателя.
Оператор `??=` (null coalescing assignment) означает: «если переменная `$moon` ещё не определена или равна `null`, присвой ей значение».
Хотя это удобно, внутри цикла такая запись может восприниматься как «магия» — к тому же важно помнить, что переменная с таким именем не должна быть объявлена ранее.
Чтобы избежать недопониманий, лучше сделать намерение явным:

```php
// Хорошо [✓]
$moon = MoonPhase::forToday();

foreach ($users as $user) {
    $user->notify(new MoonPhaseNotification($moon));
}
```

Сохранение результата в переменную делает код не только читаемее, но и предсказуемее.

### Используйте подходящие структуры данных

Выбирайте правильную структуру данных с самого начала, чтобы не пришлось преобразовывать и адаптировать её в процессе.
Часто начинают с базовых типов, например хранение данных в массивах кажется очень заманчивым и удобным решением: можно
просто взять нужное значение по ключу.
Но затем в коде начинают появляться конструкции вроде:

```php
// Плохо [✗]
if (isset($user['address']['city'])) {
    $city = $user['address']['city'];
} else {
    $city = 'Неизвестно';
}
```

Сначала это кажется безобидным. 
Но когда таких вложенных ключей становится много, и данные разбросаны по всему коду, всё усложняется.
Вместо того, что бы описывать логику поведения, мы продолжаем манипуляции с данными на низком уровне.
Чтобы получить ещё одно значение, снова и снова приходится писать `isset` с длинной цепочкой:

```php
// Плохо [✗]
if (
    isset($user['address']['city']) &&
    isset($user['preferences']['language'])
) {
    $city = $user['address']['city'];
    $language = $user['preferences']['language'];
}
```

Такая практика раскрывает детали хранения данных во всех местах их использования и делает код процедурным: каждый шаг
работы с «сырыми» данными прописывается вручную, вместо того чтобы описать желаемое поведение

Например, фильтрация заказов пользователя по городу при использовании массивов выглядит так:

```php
// Плохо [✗]
if (isset($user['id'], $user['address']['city'])) {
    $city = $user['address']['city'];

    $userOrders = array_filter(
        $orders,
        function ($order) use ($user, $city) {
            return $order['user_id'] === $user['id']
             && $order['city'] === $city;
        }
    );
} else {
    $userOrders = [];
}
```

Здесь постоянно приходится повторять проверки и раскрывать детали — где у пользователя лежит город, как устроен заказ.
Если структура данных изменится, код придётся менять во многих местах. Это сложно и рискованно.
Использование объектов и инкапсуляция данных позволяют скрыть детали и упростить взаимодействие:

```php
// Хорошо [✓]
$city = $user->address?->city() ?? 'Неизвестно';
$language = $user->preferences?->language ?? 'ru';
```

Код становится линейным и более читаемым, а изменения внутренней структуры данных требуют правок только внутри
соответствующих классов.

Для полного устранения проверок на `null` можно применить паттерн `Null Object` — объект-заглушку, возвращающий значения
по умолчанию, что дополнительно упрощает код:

```php
// Хорошо [✓]
class NullAddress {
    public function city()
    {
        return 'Неизвестно';
    }
}

$city = $user->address->city();
```

Если же продолжать использовать массивы с `isset` повсюду, проект превратится в спагетти из проверок и длинных цепочек
ключей.
Это затруднит чтение и увеличит количество ошибок — они всегда рядом там, где много ручных проверок.

> {notice} Паттерн `Null Object` полезен не только для возврата значений по умолчанию, но и для реализации методов, которые
> не должны выполнять никаких действий.

### Место для расширения

Иногда нужно немного изменить поведение класса — добавить одно условие, поменять одну строчку, подставить другую
функцию. Казалось бы, мелочь, но уже появляются соблазны.

Часто мы думаем: «Создам новый класс, унаследуюсь от старого и переопределю нужный метод». Быстро, просто и вроде
аккуратно.

```php
class ReportGenerator {
    public function generate() {
        return "Отчёт: стандартный формат";
    }
}

class CustomReportGenerator extends ReportGenerator {
    public function generate() {
        return "Отчёт: специальный формат для фин. отдела";
    }
}
```

На первый взгляд — разумно. Но через месяц таких потомков будет уже пять, потом десять. А кто-то добавит изменения в
родительский класс, чтобы «не трогать потомков», — и структура начинает шататься.

Вы смотрите на этот зоопарк и задаётесь вопросом: где живёт нужная логика? В родителе? В потомке? В обоих? В каком из
пятнадцати классов?

Всё стало сложнее, чем было. Хотя вы просто хотели добавить одно небольшое изменение.

Почему так происходит? Потому что в коде нет места для изменений без разрушений. Нет точки расширения — шва (seam). В
результате единственный способ изменить поведение — наследование, переопределение и копипаст.

Вместо наследования можно сделать в классе точку расширения — шов, который позволяет изменить поведение без правки
существующего кода. Например, передать колбэк или другой объект. Главное — не трогать внутренности класса, всё меняется
снаружи.

Простой пример:

```php
class ReportGenerator {
    public function __construct(private Closure $formatter) {}

    public function generate(): string {
        $data = [
            'title' => 'Отчёт',
            'content' => 'Содержимое...'
        ];

        return ($this->formatter)($data);
    }
}
```

Теперь вы определяете, как именно форматировать отчёт:

```php
$generator = new ReportGenerator(function (array $data) {
    return "{$data['title']}: {$data['content']}";
});
```

Никаких наследников. Всё поведение — в одном месте. Тестировать такой класс легко, расширять — ещё проще.

Идея очень проста:
Не спешите писать `extends`.
Спросите себя: можно ли здесь оставить шов?
Если да — вы только что сделали код гибче, проще и чище.
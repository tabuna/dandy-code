# Обработка ошибок

Каждый раз, когда вы пишете код, вы должны помнить о том, что он может сломаться. 
Ошибки могут возникать по самым разным причинам: от неправильного ввода данных до сбоев в работе внешних сервисов. 
Поэтому важно правильно обрабатывать ошибки, чтобы ваш код не падал и не оставлял пользователей в недоумении.

### Исключения

Как правило, исключения, которые вы ожидаете и планируете обрабатывать заранее, должны наследоваться от `Exception`.
Те же исключения, которые вы создаёте, но обработка которых необязательна или не предусмотрена, — лучше наследовать от
`\RuntimeException`.

Например, это ошибки, возникающие из-за неверного состояния программы, неправильного использования API или логических
ошибок.

Это связано с понятием **unchecked exceptions** — исключений, которые не требуют обязательной обработки.
Они не могут быть предсказаны заранее и проявляются только во время выполнения программы.

В PHP, в отличие от некоторых других языков, нет строгого разделения на checked и unchecked исключения,
но по смыслу `RuntimeException` относится именно к категории unchecked.

Если ваш класс наследуется от `Exception` и не обработан, инструменты вроде PhpStorm и статические анализаторы могут
обратить на это внимание,
предупреждая, что исключение не перехвачено, в то время как исключения, наследуемые от `RuntimeException`, в этом плане
рассматриваются иначе.

### Скрытое замалчивание
Абсолютно ни в коем случае нельзя «поймать и забыть» исключение.
Пустой catch или молчаливое подавление ошибок:

```php
// Плохо ❌
try {
    $this->calculate($data);
} catch (\Throwable $throwable) {
    // ничего не делаем
}
```
– «смертельно» опасен: проблема произошла, но никто об этом не узнает. 
Главное — не потерять факт ошибки. Так делать нельзя: ошибка уходит в тень, вы теряете информацию.


В некоторых случаях, чтобы избежать падения приложения, можно вернуть резервный результат:
```php
// Плохо ❌
try {
    $message = $this->greeting($time);
} catch (ExternalApiException $exception) {
    $message = 'Добро пожаловать!';
}
```

Это достаточно редко, но иногда может имеет смысл, но обязательно нужно логировать ошибку:

```php
// Хорошо ✅
try {
    $message = $this->greeting($time);
} catch (ExternalApiException $exception) {
    Log::warning('Не удалось получить приветствие', [
        'arguments' => ['time' => $time],
        'exception' => $exception
    ]);

    $message = 'Добро пожаловать!';
}
```

### Ясные ошибки 

Сообщения об ошибках должны быть максимально информативными и конкретными.
Вместо абстрактного «RuntimeException» нужно описывать, что именно произошло и где:


```php
// Плохо ❌
foreach ($users => $user) {
   if($user->isActive()){
       throw new Exception('Для удаления, пользователь не должен быть активным');
   }
}
```

Невозможно понять, какой именно пользователь вызвал ошибку. 
Что исправить, нужно добавить контекст:

```php
foreach ($users as $user) {
    if ($user->isActive()) {
        throw new RuntimeException(sprintf(
            'Нельзя удалить активного пользователя: ID=%d, email=%s',
            $user->id,
            $user->email
        ));
    }
}
```

### Обязательно мониторинг логов

Чтобы не пропускать серьезные проблемы, все необработанные исключения нужно обязательно фиксировать в логах.
Логи — это ваша единственная возможность узнать, что пошло не так, когда программа работает в производственной среде.

Обычно ошибки записывают в файл на диске и/или отправляют во внешний сервис. Но важно это делать последовательно.
Посмотрите на пример:

```php
// Плохо ❌
try {
    throw new RuntimeException("...");
} catch (Throwable $e) {
    file_put_contents('log-process.txt', 'Ошибка #5');
}

try {
    throw new RuntimeException("...");
} catch (Throwable $e) {
    file_put_contents('log-user.txt', json_encode([
        'line' => $e->getLine(),
        'status' => 500
    ]));
}
```


В этом примере исключения обработаны, но их структура абсюлютно разная, в одном формат JSON, а другом строка.
Это не позволит автоматически проанализировать их и создат лишнюю когнитивную нагрузку.

Вместо этого используйте единую точку для логирования, например:
```php
function logException(Throwable $e): void
{
    $logMessage = sprintf(
        "[%s] %s in %s on line %d\nStack trace:\n%s\n\n",
        date('Y-m-d H:i:s'),
        $e->getMessage(),
        $e->getFile(),
        $e->getLine(),
        $e->getTraceAsString()
    );

    file_put_contents(__DIR__ . '/error.log', $logMessage, FILE_APPEND);
}
```

А ещё лучше — использовать современный подход с PSR-3-совместимыми логгерами, такими как [Monolog](https://github.com/Seldaek/monolog).
Он поддерживает уровни логирования, форматирование, хендлеры и интеграцию с внешними системами.

Важно так же не писать все бесконтролько в один файл, так как его содержание будет расти.
Что может выльется в то, что любимая ide или редактор не смогут открыть файл нв 30гб
не говоря уже о том, что бы осуществить эффективный поиск по нем. 
Что бы такого не произошло можно настроить ротацию логов, например что бы каждый новый день старый лог переименовывался и  архивировался, а спустя некоторое время удалялся.
Так у вас будет меньше мусорных данных которые не нужны в контексте.

Но просто собирать логи мало. Нужно, чтобы вы сразу узнавали о проблемах. 
Для этого подключают централизованные системы мониторинга: Sentry, Graylog, ELK, или другие. 
Они собирают все ошибки в одном месте, позволяют группировать и отслеживать повторяющиеся баги, а при необходимости — шлют оповещения на почту или в мессенджеры.

### Отладка

Среди разработчиков укоренилось мнение, что пошаговая отладка, например с помощью Xdebug, признак хорошего разработчика. Выглядит это следующим образом: разработчик ставит точку остановки, затем начинает "шагать" по коду, наблюдает за значениями переменных, отслеживает условные переходы — словно читает чужие мысли.

Но позвольте — если вам нужно так делать, значит, что-то пошло не так!

Это не норма. Значит, ваш код неочевиден, сложен и плохо структурирован.

Настоящая причина, по которой вам нужно пошагово проходить каждую строчку, в том, что вы не понимаете, что происходит в системе. 
И не потому что вы недостаточно умны — а потому что код запутан. В нём всё связано со всем, всё влияет на всё, и даже чтобы просто проверить расчёт скидки, вам приходится запускать сервер, кликать через интерфейс и ставить точку останова где-то внутри `processOrder()`.

Вот как это обычно выглядит:

```php
// Плохо ❌
function handleRequest($input) {
    try {
        $value = complexCalculation($input);
        if ($value > 0) {
            $details = $this->service->getDetails($value);
            if ($details && $details['status'] == 'ok') {
                processDetails($details);
                return;
            }
        }
        for ($i = 0; $i < 5; $i++) {
            try {
                retryOperation($i);
                break;
            } catch (Exception $exception) {
                // пустое
            }
        }
    } catch (Exception $exception) {
        Log::error($e);
    }
}
```

Здесь есть и вложенные блоки `try-catch`, и `if` внутри `if`, и цикл с ловлей исключений «внутри» функции.
Без отладки трудно понять: за какой именно шаг «цепи» падает — внешняя обработка или внутренняя. Такой код трудно тестировать: чтобы проверить `handleRequest`, нужно настроить и дублировать логику `complexCalculation`, `service->getDetails` и т.д.


А теперь посмотрите, как это должно быть устроено:

```php
// TODO: пишем тест
```

Всё. Логика выделена, изолирована, читается за секунду.

Вы можете протестировать её без всякого дебаггера в тестах:

```php
// TODO: пишем тест
```


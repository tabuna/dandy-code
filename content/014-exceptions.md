# Обработка ошибок

Каждый раз, когда вы пишете код, вы должны помнить о том, что он может сломаться. 
Ошибки могут возникать по самым разным причинам: от неправильного ввода данных до сбоев в работе внешних сервисов. 
Поэтому важно правильно обрабатывать ошибки, чтобы ваш код не падал и не оставлял пользователей в недоумении.

### Исключения

Как правило, исключения, которые вы ожидаете и планируете обрабатывать заранее, должны наследоваться от `Exception`.
Те же исключения, которые вы создаёте, но обработка которых необязательна или не предусмотрена, — лучше наследовать от
`\RuntimeException`.

Например, это ошибки, возникающие из-за неверного состояния программы, неправильного использования API или логических
ошибок.

Это связано с понятием **unchecked exceptions** — исключений, которые не требуют обязательной обработки.
Они не могут быть предсказаны заранее и проявляются только во время выполнения программы.

В PHP, в отличие от некоторых других языков, нет строгого разделения на checked и unchecked исключения,
но по смыслу `RuntimeException` относится именно к категории unchecked.

Если ваш класс наследуется от `Exception` и не обработан, инструменты вроде PhpStorm и статические анализаторы могут
обратить на это внимание,
предупреждая, что исключение не перехвачено, в то время как исключения, наследуемые от `RuntimeException`, в этом плане
рассматриваются иначе.

### Скрытое замалчивание
Абсолютно ни в коем случае нельзя «поймать и забыть» исключение.
Пустой catch или молчаливое подавление ошибок:

```php
// Плохо ❌
try {
    $this->calculate($data);
} catch (\Throwable $throwable) {
    // ничего не делаем
}
```
– «смертельно» опасен: проблема произошла, но никто об этом не узнает. 
Главное — не потерять факт ошибки. Так делать нельзя: ошибка уходит в тень, вы теряете информацию.


В некоторых случаях, чтобы избежать падения приложения, можно вернуть резервный результат:
```php
// Плохо ❌
try {
    $message = $this->greeting($time);
} catch (ExternalApiException $exception) {
    $message = 'Добро пожаловать!';
}
```

Это достаточно редко, но иногда может имеет смысл, но обязательно нужно логировать ошибку:

```php
// Хорошо ✅
try {
    $message = $this->greeting($time);
} catch (ExternalApiException $exception) {
    Log::warning('Не удалось получить приветствие', [
        'arguments' => ['time' => $time],
        'exception' => $exception
    ]);

    $message = 'Добро пожаловать!';
}
```

### Ясные ошибки 

Сообщения об ошибках должны быть максимально информативными и конкретными.
Вместо абстрактного «RuntimeException» нужно описывать, что именно произошло и где:


```php
// Плохо ❌
foreach ($users => $user) {
   if($user->isActive()){
       throw new Exception(
            'Пользователь должен быть неактивен для удаления'
        );
   }
}
```

Невозможно понять, какой именно пользователь вызвал ошибку. 
Чтобы исправить, нужно добавить контекст:

```php
foreach ($users as $user) {
    if ($user->isActive()) {
        throw new RuntimeException(sprintf(
            'Нельзя удалить активного пользователя: ID=%d',
            $user->id,
        ));
    }
}
```

### Обязательно мониторинг логов

Чтобы не пропускать серьезные проблемы, все необработанные исключения нужно обязательно фиксировать в логах.
Логи — это ваша единственная возможность узнать, что пошло не так, когда программа работает в производственной среде.

Обычно ошибки записывают в файл на диске и/или отправляют во внешний сервис. Но важно это делать последовательно.
Посмотрите на пример:

```php
// Плохо ❌
try {
    throw new RuntimeException("...");
} catch (Throwable $e) {
    file_put_contents('log-process.txt', 'Ошибка #5');
}

try {
    throw new RuntimeException("...");
} catch (Throwable $e) {
    file_put_contents('log-user.txt', json_encode([
        'line' => $e->getLine(),
        'status' => 500
    ]));
}
```


В этом примере исключения обработаны, но их структура абсолютно разная, в одном формат JSON, а другом строка.
Это не позволит автоматически проанализировать их и создаст лишнюю когнитивную нагрузку.

Вместо этого используйте единую точку для логирования, например:
```php
function logException(Throwable $e): void
{
    $logMessage = sprintf(
        "[%s] %s in %s on line %d\nStack trace:\n%s\n\n",
        date('Y-m-d H:i:s'),
        $e->getMessage(),
        $e->getFile(),
        $e->getLine(),
        $e->getTraceAsString()
    );

    file_put_contents(
        __DIR__ . '/error.log',
        $logMessage,
        FILE_APPEND
    );
}
```

А ещё лучше — использовать современный подход с PSR-3-совместимыми логгерами, такими как [Monolog](https://github.com/Seldaek/monolog).
Он поддерживает уровни логирования, форматирование, хендлеры и интеграцию с внешними системами.

Важно так же не писать все бесконтрольно в один файл, так как его содержание будет расти.
Что может выльется в то, что любимая ide или редактор не смогут открыть файл на 30гб
не говоря уже о том, что бы осуществить эффективный поиск по нему. 
Что бы такого не произошло можно настроить ротацию логов, например, что бы каждый новый день старый лог переименовывался и архивировался, а спустя некоторое время удалялся.
Так у вас будет меньше мусорных данных которые не нужны в контексте.

Но просто собирать логи мало. Нужно, чтобы вы сразу узнавали о проблемах. 
Для этого подключают централизованные системы мониторинга: Sentry, Graylog, ELK, или другие. 
Они собирают все ошибки в одном месте, позволяют группировать и отслеживать повторяющиеся баги, а при необходимости — шлют оповещения на почту или в мессенджеры.

### Отладка

Среди разработчиков распространено мнение, что пошаговая отладка, например с помощью Xdebug, признак хорошего специалиста. 
Выглядит это следующим образом: разработчик ставит точку остановки, затем начинает "шагать" по коду, наблюдает за значениями переменных, отслеживает условные переходы — словно читает чужие мысли.
Якобы именно так приходит понимание, «как всё устроено».

Но позвольте — если вам нужно так делать, значит, что-то пошло не так!

Это не норма. Значит, ваш код неочевиден, сложен и плохо структурирован.

Настоящая причина, по которой вам нужно пошагово проходить каждую строчку, в том, что вы не понимаете, что происходит в системе. 
И не потому что вы недостаточно умны — а потому что код запутан. В нём всё связано со всем, всё влияет на всё, и даже чтобы просто проверить, вам приходится запускать сервер, кликать через интерфейс и ставить точку остановки где-то внутри `shouldGoOutside()`.


Представим, что система должна вернуть рекомендацию пользователю — выходить ли на улицу:

```php
// Плохо ❌
function shouldGoOutside(array $weather): bool
{
    return ! (function () use (&$weather, $check) {
        try {
            extract($weather, EXTR_SKIP);
            if ($this->check($temperature, -10, 35, function ($t) {
                return $this->isExtremeTemperature($t);
            })) {
                return false;
            }

            // ...

            foreach ($alerts as $carry) {
                try {
                    return $this->shouldPanic($carry);
                } catch (Throwable) {}
            }
        } catch (Throwable $throwable) {
            Log::error($throwable);
            return false;
        }
    })();
}
```

Здесь есть и вложенные блоки `try-catch`, и `if` внутри `if`, и цикл с ловлей исключений «внутри» функции.
Без отладки трудно понять: за какой именно шаг «цепи» падает — внешняя обработка или внутренняя. 

А теперь посмотрите, как это должно быть устроено:

```php
final class DecisionEngine
{
    /**
     * @param WeatherRule[] $rules
     */
    public function __construct(
        private array $rules
    ) {}

    public function shouldGoOutside(array $weather): bool
    {
        foreach ($this->rules as $rule) {
            if (!$rule->passes($weather)) {
                return false;
            }
        }

        return true;
    }
}
```

Всё. Логика выделена, изолирована, читается за секунду.

Вы можете протестировать её без всякого дебаггера в тестах:

```php

$engine = new DecisionEngine([
    new TemperatureRule(),
    new WindRule(),
    new PrecipitationRule(),
    new NoSevereStormAlertRule(),
]);

$engine->shouldGoOutside([
    'temperature' => 20,
    'wind' => 5,
    'precipitation' => 10,
    'alerts' => [],
]);
```

а если нужно, что-то проверить, то мы можем легко добавить тест:

```php
$rule = new WindRule();

$this->assertTrue($rule->passes(['wind' => 10]));
$this->assertFalse($rule->passes(['wind' => 25]));
$this->assertTrue($rule->passes([])); // Ветра нет — нормально

```

Отладка нужна, когда вы не можете локализовать поведение.
В хорошо структурированном коде вместо Xdebug — вы пишете `->assertTrue(...)`.
# Тесты

Слово **тестирование** испортили и изуродовали. Потому что часто под этим подразумевают ручную проверку, что задача которую делал разработчик работает как задумано после изменений. Это не то что нужно разработчику, нам нужен контроль качества.

Многие до сих пор думают, что тестированием занимается кто-то другой: тестировщик, QA-инженер, автоматизатор или великий господин начальник. Это не так.

Ты — разработчик — и есть первый тестировщик, ты запускаешь приложение, проверяешь, что оно работает, вносишь изменения и проверяешь, что всё по-прежнему работает.


### Больше юнит-тестов, меньше всего остального

В мире тестирования есть много терминов: интеграционные, e2e, smoke, UI, acceptance, snapshot, regression… Становится страшно даже начинать перечислять. Но непосредственно на качество кода влияет только один вид тестов — юнит-тесты.

Почему? Потому что они:
- Проверяют маленькие части кода (функции, методы, классы).
- Работают быстро.
- Легко читаются и поддерживаются.
- Заставляют твой код быть тестируемым, а значит — аккуратным и логичным.


О чем я говорю? Как это связано с разработкой?

Допустим у нас есть endpoint который должен вернуть фазу Луны на определенную дату. 
Мы можем написать feature-тест, который проверит, что функция, вычисляющая фазу Луны, работает правильно. 
В нем мы обратимся по адресу `/api/moon?date=2025-06-01`, получим ответ и проверим, что он соответствует ожидаемому значению.

```php
// Плохо ❌
public function test_returns_moon_phase_data(): void
{
    $response = $this->get('/api/moon', [
            'date' => 2025-06-01,
        ])
         ->assertOk()
         ->assertJsonStructure([
            'age',
            'phase',
            'distance',
            'nextNewMoon'
         ])
         ->json();

    $this->assertEquals(13.8, round($response['age'], 1));
    $this->assertEqualsWithDelta(0.47, $response['phase'], 0.01);
    $this->assertEqualsWithDelta(384400, $response['distance'], 50000);
}

```

Это хороший тест, который проверяет, что API возвращает правильные данные для известной даты. 
Он проверяет, что ответ содержит нужные поля и что значения в них соответствуют ожидаемым.

Но как именно работает функция, вычисляющая фазу Луны? 
Как она получает данные о Луне? 
Как она обрабатывает дату? И вроде бы всё хорошо, но это обманка. 
Такой тест ничего не говорит о логике внутри. 
Он — витрина. Он проверяет фасад, но не фундамент. 
Он проверяет только конечный результат, это должно быть как вишенка на торте, а не основа.

Мы можем написать в код прямо контроллере и добавить туда с десяток функций, которые будут вызывать другие функции, и в итоге получим правильный ответ. Но это фигня.

Вместо этого лучше сосредоточиться на написании как можно большего числа тестов, которые проверяют поведение отдельных компонентов в изоляции.

А для этого вам потребуется использовать объекты:

```php
// Хорошо ✅
public function test_moon_phase_for_known_date(): void
{
    $date = new DateTimeImmutable('2025-06-01');
    $moon = new MoonPhase($date);

    // Проверяем округлённые значения
    $this->assertEquals(13.8, round($moon->age, 1));
    $this->assertEqualsWithDelta(0.47, $moon->phase, 0.01); // ≈ 47% цикла
    $this->assertEqualsWithDelta(384400, $moon->distance, 50000); // ±50k км — синусоида
}
```

Такой подход заставляет вас писать код, который легко проверить и переиспользовать. 
Вы отделяете логику расчёта (в классе `MoonPhase`) от внешних интерфейсов (контроллеров, команд, CLI, API), и это делает код переносимым и модульным.

И самое важное: теперь никто не сможет просто так "вставить" бизнес-логику в контроллер — просто потому что она **уже вынесена в объект**, и её поведение **зафиксировано тестами**.


### Тесты как средство симметрии и архитектурной дисциплины

Тесты — это не просто проверка правильности работы кода. Это мощный инструмент, который помогает поддерживать симметрию и согласованность между компонентами, особенно когда они тесно связаны.

Например, в сервисе погоды могут быть два класса — экспортёр и импортёр исторических данных:

```php
$exporter = new WeatherHistoryExporter();
$exporter->export('/tmp/weather.zip');

$importer = new WeatherHistoryImporter();
$importer->import([
    'devices' => '/tmp/weather/devices.xml',
    'locations' => '/tmp/weather/locations.xml',
    'readings' => '/tmp/weather/readings.xml',
]);
```

В обычном коде вызовы этих классов часто разбросаны по разным частям приложения, и никто не замечает, что результат экспорта не подходит для импорта.

Если же написать тест, объединяющий эти сценарии в единый процесс, сразу становится очевидно, что экспорт и импорт — два конца одного процесса, и между ними должна быть полная совместимость.

Такой тест заставляет думать не только о том, что делает каждый отдельный компонент, но и о том, как классы на разных точках входа взаимодействуют, какой контракт между ними.

Это помогает сделать архитектуру цельной, логичной и поддерживаемой.

Тесты перестают быть просто проверкой — они становятся инструментом поддержания архитектурной дисциплины. Когда это понимаешь, начинаешь писать код иначе, так чтобы все части системы были симметричны и идеально подходили друг к другу.



### Arrange–Act–Assert (AAA)
Разделяйте тест на три логических фазы:

- Arrange. Подготовьте данные, объекты и окружение.
- Act. Выполните единственное действие — метод, который тестируете.
- Assert. Убедитесь, что результат совпадает с ожиданием (одно утверждение = одно тестовое поведение).

```php
public function test_something(): void
{
    // Arrange: подготовка данных
    $obj = new MyClass(...);

    // Act: выполнение действия
    $result = $obj->doWork();

    // Assert: проверка результата
    $this->assertTrue($result->isSuccessful());
}
```


Если с выолнением действия и проверкой результата всё понятно, то с подготовкой данных могут быть нюансы.
Подготовка данных это главная часть теста, и она должна быть максимально простой и понятной.

Например, если вы тестируете метод, который работает с базой данных, то вам нужно создать необходимые записи в базе. Но не нужно создавать всю базу целиком, достаточно только тех записей, которые нужны для теста.


Есть несколько способов как организовать подготовку данных. Например определить заранее записи в базе данных которые бы записывались перед исполнением теста.
```yaml
users:
  - id: 1
    name: Иван Иванов
    email: ivan.ivanov@example.com
    password: '$2y$10$e0NRDUE8...'
    created_at: 2024-05-01 10:00:00
    updated_at: 2024-05-01 10:00:00

  - id: 2
    name: Мария Петрова
    email: maria.petrova@example.com
    password: '$2y$10$Fjs98JDk...'
    created_at: 2024-05-02 12:30:00
    updated_at: 2024-05-02 12:30:00
```

Это заставляет нас каждый раз возвращается к этому файлу и обновлять его, когда мы добавляем новые поля в модель. При написании теста нам нужно сначала создать эти записи, а потом уже использовать их в тестах.
Мы не знаем, а точно ли используется пользователь #2 в проекте или мы просто забыли удалить его из этого файла.

Тогда в тесте будет выглядеть примерно так:

```php
// Плохо ❌
public function test_something(): void
{
    $user = User::find(2);
}
```

Кроме того, мы не видим ни каких подробностей пользователя который мы используем в тесте. Мы не знаем, что это за пользователь, какие у него данные и зачем он нужен.

Лучше всего, что бы подготовка была максимально близка к тестируемому коду. Например, если мы тестируем метод, который работает с пользователем, то лучше всего создать пользователя прямо в тесте:

```php
// Хорошо ✅
public function test_something(): void
{
    $user = User::factory()
        ->withPassword('password123')
        ->create();
}
```


### Рекомендации по организации тестов

Тесты должны зеркалировать структуру вашего приложения. Это поможет вам быстро находить нужные тесты и понимать, что они проверяют.

```php
tests/
├─ Unit/
│   └─ MoonPhaseTest.php
└─ Feature/
    └─ MoonPhaseTest.php
```

### Независимость тестов

Работая с тестами, иногда можно столкнуться с неприятной ситуацией: один тест проходит, только если выполняется сразу
после другого. И если изменить порядок, этот тест ломается.

Это говорит о том, что тесты зависят друг от друга. А идеальный тест всегда должен быть независимым и начинаться с
«чистого листа».

Хороший способ обнаружить такие скрытые зависимости это запускать тесты в случайном порядке. Если тест не проходит,
когда порядок перемешан, это значит, что он зависит от других, и с этим нужно что-то сделать.

PHPUnit и Laravel поддерживают специальный флаг для случайного порядка `--order-by=random`

```shell
# Для Laravel
php artisan test --order-by=random

# Для Laravel Dusk
php artisan dusk --order-by=random

# Для PHPUnit
vendor/bin/phpunit --order-by=random
```

Попробуйте запустить свои тесты в случайном порядке и посмотрите, есть ли у вас зависимые тесты. 😉

Еще лучше добавьте атрибут `executionOrder` в конфигурационный файл, что бы запуск тестов в случайном порядке был по
умолчанию 🚀.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit
        executionOrder="random"
>
```

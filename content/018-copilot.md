# Второй пилот — не капитан

В начале книги уже было отмечено: код читают гораздо чаще, чем пишут.
Сегодня у нас появился второй пилот — только теперь он не сидит рядом на соседнем кресле, а встроен прямо в редактор.
ChatGPT, Copilot и другие LLM-инструменты. Быстрые, дружелюбные, полезные.
Но не обманывайтесь: это всё ещё второй пилот, не капитан

Обычно код не меняют просто так.
Чаще всего причина — баг или новая фича и
задача для инструмента формулируется примерно так:

> «Выступи в роли X. Иногда этот код выбрасывает исключение XXX. Исправь, пожалуйста».

Но именно в таких формулировках и кроется проблема.

Если передать ему метод на 800 строк, полных противоречий, логических дыр и нелепых зависимостей — не надейся,
что он сделает из этого конфетку.
Он будет **продолжать**. Механически, без разбора.
Потому что его задача — **продолжить твой стиль**, а не **исправить твой хаос**.
Старое правило `GIGO — *Garbage In, Garbage Out*.` никуда не делось.


Рассмотрим простой пример: функция, которая записывает email в базу и отправляет приветственное письмо.
Попросим второго пилота добавить логирование:

```diff
// >_ Добавь логирование

function store()
{
    $email = $_POST['email'];

    $conn = new mysqli('localhost', 'user', 'pass', 'db');
    $conn->query("INSERT INTO users (email) VALUES ('$email')");

    mail($email, 'Hi', 'Welcome!');

+    file_put_contents(
+        'log.txt',
+        "User $email\n",
+        FILE_APPEND
+    );

    echo 'Done';
}
```

Он чертовски хорошо выполнил свою задачу, но проблема не в его работе, а в том, что переданный код
выглядит очень плохо, потому что в нем:

- Нет возврата осмысленного результата.
- SQL-инъекция (строка вставляется напрямую).
- Нет обработки ошибок.

Если ты передал мусор — метод, который и швец, и жнец, и на дуде игрец — то не удивляйся, что он туда ещё
и трубача припишет. Он **не откажет**, он скажет: «Да, командир!» — и продолжит работу.

На сайтах вроде Stack Overflow вопросы задают и решают вручную, люди. Нередко там встречаются ответы, помеченные как 
"решение", но при этом заминусованные — в комментариях поясняют: да, работает, но приведёт к плачевным последствиям в
долгосрочной перспективе. 

"Второй пилот" — помощник другого типа. Он не будет указывать на архитектурные проблемы или спорные решения, пока вы
сами его об этом не попросите. Его задача — помогать вам как можно быстрее двигаться к результату, решать
бизнес-проблемы здесь и сейчас. Но и большинство разработчиков настроены точно так же: задача должна быть закрыта, сроки — вчера, и мало кто будет
тратить время, чтобы просить помощника подумать над более выразительными именами переменных, архитектурой или стилем.

Поэтому пилот продолжает ехать по плохой дороге.
А это самое страшное — мы просто раздуваем MESS.
И не просто так, а ещё и автоматизируем его рост.

Вот почему важно начать с хорошей базы: чистого кода, понятной архитектуры, простых методов и имён.

### Контекст

У LLM-инструментов есть ограничение, про которое редко говорят — окно контекста.
Ты его не видишь, не управляешь им напрямую, но оно всегда рядом.
И иногда критически важные части твоей системы просто выпадают из внимания модели.

Появляется асимметрия. Поверхность кажется правильной, но под капотом — несовместимость.

Мы уже несколько раз в книге говорили о симметрии, но давайте повторим. 
И посмотрим на небольшой пример импортера исторических данных о погоде:

```php
$importer = new WeatherHistoryImporter();
$importer->import([
    'devices' => '/tmp/weather/devices.xml',
    'locations' => '/tmp/weather/locations.xml',
    'readings' => '/tmp/weather/readings.xml',
]);
```

Выглядит разумно. Но этот класс часть процесса импорта/экспорта. 
LLM-может не знать, о том, что класс экспорта выдает не набор xml структур, а zip-архив:

```php
$exporter = new WeatherHistoryExporter();
$exporter->export('/tmp/weather.zip');
```

И мы снова получим ассиметрию, хотя между ними должна быть полная совместимость и результат экспорта должен быть 
легко быть аргументом для импорта.

И что? Они просто не стыкуются.
LLM не «ошибся». Он просто не увидел целиком весь процесс.

Вот почему важно проверять границы.
Убедиться, что один этап действительно продолжает другой.
Что данные не просто «появились», а дошли по цепочке.
Что код — не набор изолированных кусочков, а единое движение данных.

Именно контекст определяет смысл.
И если ты его теряешь — модель его точно не найдёт.


Другой пример такой асимметрия если мы попросим LLM например внести проверку на 
уникальность в базе данных: 

```php
class TokenService
{
    public function generate(): string
    {
        return bin2hex(random_bytes(16));
    }
}
```

В ответ получишь:

```php
public function generate(): string
{
    do {
        $token = bin2hex(random_bytes(16));
    } while (DB::table('tokens')->where('value', $token)->exists());

    return $token;
}
```

Он так же отлично справился с задачей.
Но вот что он не знает: в другом месте системы у тебя уже есть `TokenRepository`, и именно он отвечает за сохранение, валидацию, поиск, всё, что связано с токенами.
И теперь у тебя два источника правды: один в `TokenService`, второй в `TokenRepository`.

Почему это произошло? Потому что пилот не видит всей картины.
Он сфокусирован на том куске, который ты показал. И всё остальное — выпадает.

Контекст — это не «удобно держать в голове». Это то, без чего невозможно принимать архитектурные решения.
LLM не знает, как устроена твоя система. Он просто не видит границ.
А ты — видишь. Должен видеть.

Поэтому проверяй стыки, проверяй зависимости, думай на шаг дальше.
Контекст — твоя ответственность.

### Не твой код

Есть и ещё одна причина, по которой работа второго пилота может вызывать раздражение или разочарование, даже если он
выполнил задачу точно.

Для очень многих разработчиков код — это не просто способ что-то реализовать.
Это форма мышления, контроля, развития. Это способ выразить себя через структуру, стиль, архитектурные решения.

Когда код рождается не в процессе размышлений, а просто появляется по запросу — остаётся ощущение отчуждённости.
Да, задача решена. Но путь к решению пройден не тобой.
Ты не выбирал между подходами, не ошибался, не искал компромисс.
А значит — не чувствуется и результат.

AI-код может выглядеть правильно, ты не уверен в его деталях, не понимаешь всех нюансов, не чувствуешь связи с ним.
Он становится чем-то внешним — как инструмент, который решил задачу, но не передал опыт.

В результате:

* вовлечённость снижается;
* мотивация падает;
* ощущение роста — отсутствует.

Именно поэтому важно не просто «принимать» результат от AI, а делать его своим:

* Понимать, откуда он взялся.
* Переписывать под собственный стиль.
* Встраивать в архитектуру осознанно.

AI — это помощник. Он может ускорить работу.
Но он не заменит твой выбор, твой стиль, твоё мышление.

Второй пилот не заменит твоё мышление — он просто помогает писать.

А хороший код начинается с тебя, а не с него!